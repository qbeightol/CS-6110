\section{Propositions as Types}
\newcommand{\fun}[3]{\lambda {#1}\!:\!{#2}.~{#3}}
\newcommand{\Fun}[2]{\Lambda {#1}.~{#2}}

\begin{enumerate}[(a)]
    \item \begin{itemize}
        \item $\Fun{\alpha, \beta, \gamma}{\fun f {\alpha \rightarrow \beta \rightarrow \gamma} {\fun b \beta {\fun a \alpha {f~a~b}}}}$
        \item $\Fun{\alpha, \beta, \gamma}{\fun f {\alpha \rightarrow \beta} {\fun g {\beta \rightarrow \gamma} {\fun x \alpha {g~(f~x)}}}}$
        \item There are two functions with this signature:
            $$ \Fun \alpha {\fun x \alpha {\fun y \alpha x}} $$
            $$ \Fun \alpha {\fun x \alpha {\fun y \alpha y}} $$
    \end{itemize}
    \item These new rules break progress---terms like $\textsf{outleft} (\textsf{inR}~a)$ get stuck. These rules
    shouldn't break preservation, however. If an $\textsf{outleft}$ or $\textsf{outright}$ term mangages to step, the
    resulting term will have the correct type.
    \item Adding a rule like $P \vee Q \Rightarrow P$ would be unsound in propositional logic. You could use that rule
    along with $P \Rightarrow P \vee Q$ to show that any proposition was true if you knew some other true
    proposition---and therefore you could prove propositions true that were also provably false. Your logic could easily
    be inconsistent.
\end{enumerate}
